#!/usr/bin/env python
from __future__ import annotations

import os
import shlex
import subprocess  # nosec:B404
import sys
from collections.abc import AsyncGenerator, Generator
from contextlib import asynccontextmanager, contextmanager
from datetime import datetime
from pathlib import Path
from typing import Annotated, Any

import anyio
import typer
from rich import print
from rich.progress import Progress, SpinnerColumn, TaskID

from .client import CdnHostBuilder, HttpSniff

app = typer.Typer()


def run_shell(cmd: str) -> None:
    print(f"--> {cmd}")
    command = shlex.split(cmd)
    cmd_env = None
    index = 0
    for i, c in enumerate(command):
        if "=" not in c:
            index = i
            break
        name, value = c.split("=")
        if cmd_env is None:
            cmd_env = os.environ.copy()
        cmd_env[name] = value
    if cmd_env is not None:
        command = command[index:]
    subprocess.run(command, env=cmd_env)  # nosec:B603


TEMPLATE = """
#!/usr/bin/env python
'''This file is auto generated by fastapi_cdn_host.
Feel free to change or remove it.
'''
import subprocess
import sys

import fastapi_cdn_host

from {} import app

fastapi_cdn_host.patch_docs(app)

def _runserver() -> int:
    r = subprocess.run(['fastapi', 'dev', __file__])
    return int(bool(r.returncode))

if __name__ == '__main__':
    sys.exit(_runserver())
"""


def write_app(dest: Path, from_path: str | Path) -> None:
    module = Path(from_path).stem
    size = dest.write_text(TEMPLATE.format(module).strip())
    print(f"Create {dest} with {size=}")


@contextmanager
def patch_app(path: str | Path, remove: bool = True) -> Generator[Path, None, None]:
    ident = f"{datetime.now():%Y%m%d%H%M%S}"
    app_file = Path(f"app_{ident}.py")
    write_app(app_file, path)
    try:
        yield app_file
    finally:
        if remove:
            app_file.unlink()
            print(f"Auto remove temp file: {app_file}")


@asynccontextmanager
async def percentbar(msg: str, **kwargs: Any) -> AsyncGenerator[None, None]:
    """Progressbar with custom font color

    :param msg: prompt message.
    """
    seconds = kwargs.pop("seconds", 5)
    color = kwargs.pop("color", "")
    total = seconds * 100

    async def play(progress: Progress, task: TaskID) -> None:
        expected, threshold = 1 / 2, 0.8
        cost = seconds * expected
        quick = int(total * threshold)
        delay = cost / quick
        for _ in range(quick):
            await anyio.sleep(delay)
            progress.advance(task)
        cost = seconds - cost
        slow = total - quick
        delay = cost / slow
        for _ in range(slow):
            await anyio.sleep(delay)
            progress.advance(task)

    with Progress(**kwargs) as p:
        prompt = f"{msg}:"
        if color:
            prompt = f"[{color}]" + prompt
        t = p.add_task(prompt, total=total)
        async with anyio.create_task_group() as tg:
            tg.start_soon(play, p, t)
            yield
            tg.cancel_scope.cancel()
            p.update(t, completed=total)


@contextmanager
def spinnerbar(
    msg: str, color: str | None = None, **kwargs: Any
) -> Generator[None, None, None]:
    kwargs.setdefault("transient", True)
    with Progress(
        SpinnerColumn(), *Progress.get_default_columns(), **kwargs
    ) as progress:
        if color:
            progress.add_task(f"[{color}]{msg}...", total=None)
        else:
            progress.add_task(f"{msg}...", total=None)
        yield


async def download_offline_assets(dirname: str, timeout: float = 30) -> None:
    cwd = await anyio.Path.cwd()
    static_root = cwd / dirname
    if not await static_root.exists():
        await static_root.mkdir(parents=True)
        print(f"Directory {static_root} created.")
    else:
        async for p in static_root.glob("swagger-ui*.js"):
            relative_path = p.relative_to(cwd)
            print(f"{relative_path} already exists. abort!")
            return
    async with percentbar("Comparing cdn hosts response speed"):
        urls = await CdnHostBuilder.sniff_the_fastest()
    print("Result:", urls)
    with spinnerbar("Fetching files from cdn", color="yellow"):
        url_list = [urls.js, urls.css, urls.redoc]
        contents = await HttpSniff.bulk_fetch(
            url_list, get_content=True, total_seconds=timeout
        )
        for url, content in zip(url_list, contents):
            if not content:
                print(f"[red]ERROR:[/red] Failed to fetch content from {url}")
            else:
                path = static_root / Path(url).name
                size = await path.write_bytes(content)
                print(f"Write to {path} with {size=}")
    print("Done.")


def handle_cache() -> None:
    exists, cache_path = CdnHostBuilder.get_cache_file()
    if not exists:
        typer.echo("Cache not create yet.")
        return
    if "--remove" in sys.argv:
        cache_path.unlink()
        typer.secho(
            f"Success to remove cache file({cache_path})", fg=typer.colors.GREEN
        )
    else:
        typer.echo(f"Content of cache file({cache_path}):\n{cache_path.read_text()}")
        if "--reload" in sys.argv:
            cache_path.unlink()
            with spinnerbar("Refreshing cache", color="yellow"):
                CdnHostBuilder(cache=True).run()
            typer.echo(f"Cache file updated:\n{cache_path.read_text()}")


@app.command()
def dev(
    path: Annotated[
        Path,
        typer.Argument(
            help=(
                "A path to a Python file or package directory"
                " (with [blue]__init__.py[/blue] file)"
                " containing a [bold]FastAPI[/bold] app."
                " If not provided, a default set of paths will be tried."
            )
        ),
    ],
    port: Annotated[
        int,
        typer.Option(
            help=(
                "The port to serve on."
                " You would normally have a termination proxy on top (another program)"
                " handling HTTPS on port [blue]443[/blue] and HTTP on port [blue]80[/blue],"
                " transferring the communication to your app."
            )
        ),
    ] = 0,
    remove: Annotated[
        bool,
        typer.Option(
            help="Whether remove the temp app_<time>.py file after server stopped."
        ),
    ] = True,
    prod: Annotated[
        bool,
        typer.Option(help="Whether enable production mode."),
    ] = False,
    reload: Annotated[
        bool,
        typer.Option(help="Enable auto-reload of the server when (code) files change."),
    ] = True,
) -> None:
    if str(path) == "offline":
        anyio.run(download_offline_assets, "static")
        return
    elif str(path) == "cache":
        handle_cache()
        return
    with patch_app(path, remove) as file:
        mode = "run" if prod else "dev"
        cmd = f"PYTHONPATH=. fastapi {mode} {file}"
        if port:
            cmd += f" --{port=}"
        if not reload and not prod:
            cmd += " --no-reload"
        run_shell(cmd)


def main() -> None:
    app()


if __name__ == "__main__":
    main()
